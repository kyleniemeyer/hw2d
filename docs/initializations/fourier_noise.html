<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>hw2d.initializations.fourier_noise API documentation</title>
<meta name="description" content="`fourier_noise.py`: A module to generate 2D noise patterns using the Fast Fourier Transform (FFT) â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hw2d.initializations.fourier_noise</code></h1>
<script type="text/javascript" async
src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
</header>
<section id="section-intro">
<p><code>fourier_noise.py</code>: A module to generate 2D noise patterns using the Fast Fourier Transform (FFT).</p>
<p>This module provides functionality to generate 2D noise patterns based on Fourier space manipulation.
The generated noise can be controlled by specifying the desired resolution, size, scale, frequency range,
and wavelength range. The resulting noise can be useful for various applications in simulations, testing,
and visualization.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
`fourier_noise.py`: A module to generate 2D noise patterns using the Fast Fourier Transform (FFT).

This module provides functionality to generate 2D noise patterns based on Fourier space manipulation.
The generated noise can be controlled by specifying the desired resolution, size, scale, frequency range, 
and wavelength range. The resulting noise can be useful for various applications in simulations, testing,
and visualization.
&#34;&#34;&#34;
import numpy as np
from typing import Tuple


def get_fft_noise(
    resolution: Tuple[int, int],
    size: float,
    scale: float,
    min_frequency: float = 0,
    max_frequency: float = 0,
    min_wavelength: float = 0,
    max_wavelength: float = 0,
    factor: int = 2,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Generate a 2D noise pattern using the FFT.

    This function creates a 2D noise pattern based on standard normal distributions in Fourier space.
    It allows for control over the frequency and wavelength components of the noise through the provided parameters.

    Args:
        resolution (Tuple[int, int]): The dimensions of the generated noise.
        size (float): Physical size.
        scale (float): Scaling factor for the frequencies.
        min_frequency (float, optional): Minimum frequency for filtering. Default is 0.
        max_frequency (float, optional): Maximum frequency for filtering. Default is 0.
        min_wavelength (float, optional): Minimum wavelength for filtering. Default is 0.
        max_wavelength (float, optional): Maximum wavelength for filtering. Default is 0.
        factor (int, optional): Factor used in calculating the frequency components. Default is 2.

    Returns:
        np.ndarray: The generated 2D noise pattern.
    &#34;&#34;&#34;
    # Calculate random complex values
    shape = (1, *resolution, 1)
    rnd_real = np.random.standard_normal(shape).astype(np.complex128)
    rnd_imag = 1j * np.random.standard_normal(shape).astype(np.complex128)
    rndj = rnd_real + rnd_imag

    # Calculate frequency components
    k = np.meshgrid(*[np.fft.fftfreq(int(n)) for n in resolution], indexing=&#34;ij&#34;)
    k = np.expand_dims(np.stack(k, -1), 0)
    k = k * resolution / size * scale  # in physical units
    k = np.sum(np.abs(k) ** factor, axis=-1, keepdims=True)

    # Convert wavelengths to frequencies if provided
    if max_wavelength:
        min_frequency = 1 / max_wavelength
    if min_wavelength:
        max_frequency = 1 / min_wavelength

    # Create frequency mask
    weight_mask = np.ones(shape)
    if min_frequency:
        weight_mask += 1 / (1 + np.exp((min_frequency - k) * 1e3)) - 1
    if max_frequency:
        with np.errstate(divide=&#34;ignore&#34;, invalid=&#34;ignore&#34;):
            weight_mask -= 1 / (1 + np.exp((max_frequency - k) * 1e3))
    # Check weight mask
    assert np.all(weight_mask &lt;= 1) and np.all(
        weight_mask &gt;= 0
    ), &#34;Weight mask values out of bounds.&#34;

    # Handle division by zero for k
    k[(0,) * len(k.shape)] = np.inf
    inv_k = 1 / k
    inv_k[(0,) * len(k.shape)] = 0

    # Compute result
    smoothness = 1
    fft = rndj * inv_k**smoothness * weight_mask
    array = np.real(np.fft.ifft2(fft, axes=[1, 2]))
    array /= np.std(array, axis=tuple(range(1, len(array.shape))), keepdims=True)
    array -= np.mean(array, axis=tuple(range(1, len(array.shape))), keepdims=True)
    array = array.astype(np.float64)
    return array[0, ..., 0]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="hw2d.initializations.fourier_noise.get_fft_noise"><code class="name flex">
<span>def <span class="ident">get_fft_noise</span></span>(<span>resolution:Â Tuple[int,Â int], size:Â float, scale:Â float, min_frequency:Â floatÂ =Â 0, max_frequency:Â floatÂ =Â 0, min_wavelength:Â floatÂ =Â 0, max_wavelength:Â floatÂ =Â 0, factor:Â intÂ =Â 2) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a 2D noise pattern using the FFT.</p>
<p>This function creates a 2D noise pattern based on standard normal distributions in Fourier space.
It allows for control over the frequency and wavelength components of the noise through the provided parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resolution</code></strong> :&ensp;<code>Tuple[int, int]</code></dt>
<dd>The dimensions of the generated noise.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>float</code></dt>
<dd>Physical size.</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>float</code></dt>
<dd>Scaling factor for the frequencies.</dd>
<dt><strong><code>min_frequency</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Minimum frequency for filtering. Default is 0.</dd>
<dt><strong><code>max_frequency</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Maximum frequency for filtering. Default is 0.</dd>
<dt><strong><code>min_wavelength</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Minimum wavelength for filtering. Default is 0.</dd>
<dt><strong><code>max_wavelength</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Maximum wavelength for filtering. Default is 0.</dd>
<dt><strong><code>factor</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Factor used in calculating the frequency components. Default is 2.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The generated 2D noise pattern.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fft_noise(
    resolution: Tuple[int, int],
    size: float,
    scale: float,
    min_frequency: float = 0,
    max_frequency: float = 0,
    min_wavelength: float = 0,
    max_wavelength: float = 0,
    factor: int = 2,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Generate a 2D noise pattern using the FFT.

    This function creates a 2D noise pattern based on standard normal distributions in Fourier space.
    It allows for control over the frequency and wavelength components of the noise through the provided parameters.

    Args:
        resolution (Tuple[int, int]): The dimensions of the generated noise.
        size (float): Physical size.
        scale (float): Scaling factor for the frequencies.
        min_frequency (float, optional): Minimum frequency for filtering. Default is 0.
        max_frequency (float, optional): Maximum frequency for filtering. Default is 0.
        min_wavelength (float, optional): Minimum wavelength for filtering. Default is 0.
        max_wavelength (float, optional): Maximum wavelength for filtering. Default is 0.
        factor (int, optional): Factor used in calculating the frequency components. Default is 2.

    Returns:
        np.ndarray: The generated 2D noise pattern.
    &#34;&#34;&#34;
    # Calculate random complex values
    shape = (1, *resolution, 1)
    rnd_real = np.random.standard_normal(shape).astype(np.complex128)
    rnd_imag = 1j * np.random.standard_normal(shape).astype(np.complex128)
    rndj = rnd_real + rnd_imag

    # Calculate frequency components
    k = np.meshgrid(*[np.fft.fftfreq(int(n)) for n in resolution], indexing=&#34;ij&#34;)
    k = np.expand_dims(np.stack(k, -1), 0)
    k = k * resolution / size * scale  # in physical units
    k = np.sum(np.abs(k) ** factor, axis=-1, keepdims=True)

    # Convert wavelengths to frequencies if provided
    if max_wavelength:
        min_frequency = 1 / max_wavelength
    if min_wavelength:
        max_frequency = 1 / min_wavelength

    # Create frequency mask
    weight_mask = np.ones(shape)
    if min_frequency:
        weight_mask += 1 / (1 + np.exp((min_frequency - k) * 1e3)) - 1
    if max_frequency:
        with np.errstate(divide=&#34;ignore&#34;, invalid=&#34;ignore&#34;):
            weight_mask -= 1 / (1 + np.exp((max_frequency - k) * 1e3))
    # Check weight mask
    assert np.all(weight_mask &lt;= 1) and np.all(
        weight_mask &gt;= 0
    ), &#34;Weight mask values out of bounds.&#34;

    # Handle division by zero for k
    k[(0,) * len(k.shape)] = np.inf
    inv_k = 1 / k
    inv_k[(0,) * len(k.shape)] = 0

    # Compute result
    smoothness = 1
    fft = rndj * inv_k**smoothness * weight_mask
    array = np.real(np.fft.ifft2(fft, axes=[1, 2]))
    array /= np.std(array, axis=tuple(range(1, len(array.shape))), keepdims=True)
    array -= np.mean(array, axis=tuple(range(1, len(array.shape))), keepdims=True)
    array = array.astype(np.float64)
    return array[0, ..., 0]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hw2d.initializations" href="index.html">hw2d.initializations</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="hw2d.initializations.fourier_noise.get_fft_noise" href="#hw2d.initializations.fourier_noise.get_fft_noise">get_fft_noise</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>